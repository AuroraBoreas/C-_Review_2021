using System;

namespace Basic_Mechnism
{

    class Car
    {
        public readonly int m_maxSpeed;
        private int m_speed;

        public Car(int max)
        {
            m_maxSpeed = max;
        }

        public Car()
        { m_maxSpeed = 55; }

        public int Speed
        {
            get => m_speed;
            set
            {
                m_speed = value;
                if(m_speed > m_maxSpeed)
                {
                    m_speed = m_maxSpeed;
                }
            }
        }
    }

    // since MiniVan "is-a" Car
    sealed class MiniVan: Car {}

    class LuxMiniVan: MiniVan {}
    
    class Program
    {
        static int Main(string[] args)
        {
            // inheritance
            {
                /*
                + relationship
                    - is-a
                    - has-a

                + inherited
                    - same mechnism in C++
                    - ctors are NOT inherited
                      why: it makes sence that ctors of a cls are destined to serve the cls itself

                    - but why same design does NOT work in c++? see class MiniVan definition
                      answer: c# compiler sets up data members(ValueType or ReferenceType) at compile time
                              due to this reason, c# class default ctor always works fine;
                              even its derived class also compiles like a blackmagic

                              c++ can achieve the same effect if u design it well enough
                              c++ compiler tries to initialize RefType automatically using default constructor
                              but default ctor is not always available;
                              default ctor is not autogenerated by compiler if programmer defined custom ctors

                + Multiple Inheritance
                    MI is not supported by c#

                +

                */ 
                FuckBasicInheritance();
            }

            // readonly vs const
            {
                /*
                
                + comparison table

                    | item      | const     | readonly      |
                    |-----------|-----------|---------------|
                    | init      | when declare | ctor; declaration |
                    | when      | compile time | run time   |
                    | effeciency | memory save | performance penalty, always copy |
                

                */ 

            }

            // sealed kw
            {
                /*
                
                + mechnism
                    - kw sealed prevents inheritance occuring
                    - c++ does NOT have such a kw;

                + usage
                    - most often, sealing a cls maeks sense when u are designning a utility cls
                
                */ 

            }

            // string vs String in c#
            {
                /*
                string is an alias of System.String
                just like 
                int is an alias of System.Int32
                
                */ 

            }

            return 0;
        }

        static void FuckBasicInheritance()
        {
            System.Console.WriteLine("=> fuck basic inheritance:");

            Car c1 = new Car(80);
            c1.Speed = 50;

            System.Console.WriteLine($"my car is going {c1.Speed} MPH");
            Console.ReadLine();
        }

        static void FuckMiniCar()
        {
            System.Console.WriteLine("=> fuck mini van:");

            MiniVan mv = new MiniVan();
            mv.Speed = 10;

            System.Console.WriteLine($"my van is going {mv.Speed} MPH");
            Console.ReadLine();
        }
    }
}